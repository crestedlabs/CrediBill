# Recurring Payments Integration Guide

## Overview

CrediBill is a **subscription tracking service** that helps you manage recurring billing without handling payment collection. Your app collects payments directly from customers using your preferred payment providers, while CrediBill tracks subscription lifecycles and sends real-time webhooks.

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Your App      â”‚    â”‚   CrediBill     â”‚    â”‚ Payment Providerâ”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ â€¢ Payment UI    â”‚â—„â”€â”€â–ºâ”‚ â€¢ Subscriptions â”‚â—„â”€â”€â–ºâ”‚ â€¢ Flutterwave   â”‚
â”‚ â€¢ Webhook recv  â”‚    â”‚ â€¢ Invoices      â”‚    â”‚ â€¢ PawaPay       â”‚
â”‚ â€¢ User mgmt     â”‚    â”‚ â€¢ Webhooks      â”‚    â”‚ â€¢ Pesapal       â”‚
â”‚                 â”‚    â”‚ â€¢ Tracking      â”‚    â”‚ â€¢ DPO           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Flow Summary

1. **Your App**: Creates subscriptions in CrediBill, collects payments from customers
2. **Payment Providers**: Process payments and send webhooks to CrediBill
3. **CrediBill**: Tracks subscription status, sends webhooks to your app
4. **Your App**: Receives CrediBill webhooks, manages user access

---

## Implementation Steps

### 1. Configure Your App in CrediBill

```typescript
// Create your pricing plans
const planResponse = await fetch("https://api.credibill.com/v1/plans", {
  method: "POST",
  headers: {
    Authorization: `Bearer ${CREDIBILL_API_KEY}`,
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    name: "Pro Plan",
    description: "Full access to all features",
    pricingModel: "flat",
    baseAmount: 25000, // 25,000 UGX/month
    currency: "UGX",
    interval: "monthly",
    trialDays: 7,
  }),
});

// Configure webhook endpoint (webhook secret is auto-generated by CrediBill)
const webhookResponse = await fetch(
  "https://api.credibill.com/v1/apps/webhooks",
  {
    method: "PUT",
    headers: {
      Authorization: `Bearer ${CREDIBILL_API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      webhookUrl: "https://yourapp.com/webhooks/credibill",
      // Webhook secret is auto-generated and returned in response
    }),
  }
);

const webhookConfig = await webhookResponse.json();
console.log("Your webhook secret:", webhookConfig.webhookSecret);
// Store this secret securely - you'll need it to verify webhook signatures
```

### 2. Configure Payment Provider Webhooks (CRITICAL!)

**This step is essential** - without it, CrediBill won't know when payments succeed or fail.

#### Add CrediBill webhook URLs to your payment provider dashboards:

**Flutterwave:**

- Dashboard â†’ Settings â†’ Webhooks
- Add: `https://giant-goldfish-922.convex.site/webhooks/flutterwave`

**PawaPay:**

- Dashboard â†’ API Configuration â†’ Webhooks
- Add: `https://giant-goldfish-922.convex.site/webhooks/pawapay?appId={your-app-id}`

**Pesapal:**

- Dashboard â†’ Developer â†’ IPN Settings
- Add: `https://giant-goldfish-922.convex.site/webhooks/pesapal`

**DPO Pay:**

- Dashboard â†’ Payment Options â†’ Callback URLs
- Add: `https://giant-goldfish-922.convex.site/webhooks/dpo`

> **âš ï¸ Important:** Use your **actual payment credentials** when making payments so the provider can authenticate and send webhooks to CrediBill.

### 3. Create Customers and Subscriptions

```typescript
// When a user signs up
async function createSubscription(userEmail: string, planId: string) {
  // Create customer in CrediBill
  const customerResponse = await fetch(
    "https://api.credibill.com/v1/customers",
    {
      method: "POST",
      headers: {
        Authorization: `Bearer ${CREDIBILL_API_KEY}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        email: userEmail,
        first_name: user.firstName,
        last_name: user.lastName,
        externalCustomerId: user.id, // Your user ID
      }),
    }
  );

  const customer = await customerResponse.json();

  // Create subscription (starts in trial)
  const subscriptionResponse = await fetch(
    "https://api.credibill.com/v1/subscriptions",
    {
      method: "POST",
      headers: {
        Authorization: `Bearer ${CREDIBILL_API_KEY}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        customerId: customer.id,
        planId: planId,
        // Will start in "trialing" status
      }),
    }
  );

  const subscription = await subscriptionResponse.json();

  // Store subscription ID in your database
  await db.users.update(user.id, {
    credibillCustomerId: customer.id,
    credibillSubscriptionId: subscription.id,
    subscriptionStatus: "trialing",
  });

  return subscription;
}
```

### 4. Handle Payment Collection

```typescript
// When trial expires or payment is due
async function collectPayment(subscription: Subscription, user: User) {
  const paymentData = {
    amount: subscription.plan.baseAmount,
    currency: subscription.plan.currency,
    customer: {
      email: user.email,
      phone: user.phone,
      name: `${user.firstName} ${user.lastName}`,
    },
    // CRITICAL: Include CrediBill subscription ID as reference
    // This is how CrediBill matches payments to subscriptions
    tx_ref: subscription.id,
    customizations: {
      title: `${subscription.plan.name} - Monthly Payment`,
      description: `Payment for ${user.email}`,
    },
    redirect_url: `https://yourapp.com/payment-success`,
    payment_options: "card,mobilemoney,ussd",
  };

  // Example with Flutterwave (use YOUR credentials)
  const flutterwaveResponse = await fetch(
    "https://api.flutterwave.com/v3/payments",
    {
      method: "POST",
      headers: {
        Authorization: `Bearer ${FLUTTERWAVE_SECRET_KEY}`, // Your actual key
        "Content-Type": "application/json",
      },
      body: JSON.stringify(paymentData),
    }
  );

  const paymentLink = await flutterwaveResponse.json();

  // Redirect user to payment page
  return paymentLink.data.link;
}

// Handle payment callback from provider
app.post("/payment/callback/flutterwave", async (req, res) => {
  const { status, transaction_id, tx_ref } = req.query;

  if (status === "successful") {
    // Payment successful!
    // CrediBill will receive the webhook from Flutterwave
    // and send you a subscription.activated webhook

    // Optional: Verify payment with provider
    const verification = await fetch(
      `https://api.flutterwave.com/v3/transactions/${transaction_id}/verify`,
      {
        headers: { Authorization: `Bearer ${FLUTTERWAVE_SECRET_KEY}` },
      }
    );

    const transaction = await verification.json();

    if (transaction.status === "success") {
      // Wait for CrediBill webhook to activate subscription
      res.redirect("/dashboard?payment=success");
    }
  } else {
    // Payment failed
    res.redirect("/billing?payment=failed");
  }
});
```

### 5. Handle CrediBill Webhooks

```typescript
import crypto from 'crypto';

app.post('/webhooks/credibill', async (req, res) => {
  // Verify webhook signature (REQUIRED for security)
  const signature = req.headers['x-webhook-signature'];
  const payload = JSON.stringify(req.body);
  const expectedSignature = crypto
    .createHmac('sha256', process.env.CREDIBILL_WEBHOOK_SECRET!)
    .update(payload)
    .digest('hex');

  if (signature !== expectedSignature) {
    return res.status(401).json({ error: 'Invalid signature' });
  }

  const { event, payload: data } = req.body;

  try {
    switch (event) {
      case 'subscription.created':
        await handleSubscriptionCreated(data);
        break;

      case 'subscription.activated':
        await handleSubscriptionActivated(data);
        break;

      case 'subscription.renewed':
        await handleSubscriptionRenewed(data);
        break;

      case 'subscription.cancelled':
        await handleSubscriptionCancelled(data);
        break;

      case 'subscription.trial_expired':
        await handleTrialExpired(data);
        break;

      case 'subscription.past_due':
        await handleSubscriptionPastDue(data);
        break;

      case 'payment.due':
        await handlePaymentDue(data);
        break;

      case 'payment.failed':
        await handlePaymentFailed(data);
        break;

      case 'invoice.created':
        await handleInvoiceCreated(data);
        break;

      case 'invoice.paid':
        await handleInvoicePaid(data);
        break;

      case 'customer.updated':
        await handleCustomerUpdated(data);
        break;

      default:
        console.log('Unhandled webhook event:', event);
    }

    res.status(200).json({ received: true });
  } catch (error) {
    console.error('Webhook processing error:', error);
    res.status(500).json({ error: 'Processing failed' });
  }
});

// Webhook handlers
async function handleSubscriptionActivated(data: any) {
  const { subscription, customer } = data;

  // Find user by CrediBill customer ID or external ID
  const user = await db.users.findFirst({
    where: {
      OR: [
        { credibillCustomerId: customer.id },
        { id: customer.externalCustomerId }
      ]
    }
  });

  if (user) {
    // Grant full access
    await db.users.update(user.id, {
      subscriptionStatus: 'active',
      subscriptionActivatedAt: new Date(),
      trialEnded: true
    });

    // Send welcome email
    await sendEmail({
      to: user.email,
      subject: 'Welcome to Pro!',
      template: 'subscription-activated',
      data: { user, plan: subscription.plan }
    });

    console.log(\`Subscription activated for \${user.email}\`);
  }
}

async function handleTrialExpired(data: any) {
  const { subscription, customer } = data;

  const user = await findUserByCustomer(customer);
  if (user) {
    // Send payment reminder
    await sendEmail({
      to: user.email,
      subject: 'Your trial has expired',
      template: 'trial-expired',
      data: {
        user,
        paymentUrl: \`https://yourapp.com/billing?action=pay&subscription=\${subscription.id}\`
      }
    });

    // Optionally restrict access
    await db.users.update(user.id, {
      subscriptionStatus: 'trial_expired',
      accessLevel: 'limited'
    });
  }
}

async function handlePaymentDue(data: any) {
  const { subscription, customer, invoice } = data;

  const user = await findUserByCustomer(customer);
  if (user) {
    // Create payment link
    const paymentLink = await collectPayment(subscription, user);

    // Send payment reminder
    await sendEmail({
      to: user.email,
      subject: 'Payment Due',
      template: 'payment-due',
      data: {
        user,
        invoice,
        paymentLink,
        dueDate: new Date(invoice.dueDate)
      }
    });
  }
}

async function handleSubscriptionPastDue(data: any) {
  const { subscription, customer, failed_attempts } = data;

  const user = await findUserByCustomer(customer);
  if (user) {
    // Restrict access
    await db.users.update(user.id, {
      subscriptionStatus: 'past_due',
      accessLevel: 'suspended'
    });

    // Send urgent payment notice
    await sendEmail({
      to: user.email,
      subject: 'Urgent: Account Suspended',
      template: 'past-due',
      data: { user, failed_attempts }
    });
  }
}

async function handleSubscriptionCancelled(data: any) {
  const { subscription, customer } = data;

  const user = await findUserByCustomer(customer);
  if (user) {
    // Revoke access
    await db.users.update(user.id, {
      subscriptionStatus: 'cancelled',
      accessLevel: 'none',
      cancelledAt: new Date()
    });

    // Send cancellation confirmation
    await sendEmail({
      to: user.email,
      subject: 'Subscription Cancelled',
      template: 'subscription-cancelled',
      data: { user }
    });
  }
}

// Helper function
async function findUserByCustomer(customer: any) {
  return await db.users.findFirst({
    where: {
      OR: [
        { credibillCustomerId: customer.id },
        { id: customer.externalCustomerId }
      ]
    }
  });
}
```

### 6. User Interface

```typescript
// Billing page component
function BillingPage() {
  const { user } = useAuth();
  const [subscription, setSubscription] = useState(null);

  useEffect(() => {
    // Fetch subscription status from your API
    // (which gets it from CrediBill)
    fetchSubscriptionStatus();
  }, []);

  const handleUpgrade = async () => {
    // Create payment link for current subscription
    const response = await fetch('/api/create-payment', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        subscriptionId: user.credibillSubscriptionId
      })
    });

    const { paymentUrl } = await response.json();
    window.location.href = paymentUrl;
  };

  return (
    <div className="billing-page">
      {user.subscriptionStatus === 'trialing' && (
        <div className="trial-banner">
          <p>Your trial expires on {user.trialExpiresAt}</p>
          <button onClick={handleUpgrade}>Subscribe Now</button>
        </div>
      )}

      {user.subscriptionStatus === 'past_due' && (
        <div className="past-due-banner">
          <p>Your subscription is past due. Please update your payment.</p>
          <button onClick={handleUpgrade}>Pay Now</button>
        </div>
      )}

      {user.subscriptionStatus === 'active' && (
        <div className="active-subscription">
          <p>âœ… Your subscription is active</p>
          <p>Next billing: {subscription?.nextPaymentDate}</p>
        </div>
      )}
    </div>
  );
}
```

---

## Best Practices

### 1. **Payment Provider Webhook Setup (CRITICAL)**

You MUST configure your payment provider to send webhooks to CrediBill's endpoints, or the system won't work.

### 2. **Webhook Secret is Auto-Generated**

CrediBill generates webhook secrets automatically for security - you don't create them, you receive them.

### 3. **Always Use tx_ref/Reference**

Include the CrediBill subscription ID as the payment reference so CrediBill can match payments to subscriptions.

### 2. **Handle All Webhook Events**

Implement handlers for all relevant events to provide the best user experience.

### 3. **Graceful Degradation**

Design your app to handle webhook delays or failures gracefully.

### 4. **Test Mode**

Use CrediBill's test mode during development to avoid real charges.

### 5. **Signature Verification**

Always verify webhook signatures to prevent fraud.

### 6. **Idempotency**

Make webhook handlers idempotent since webhooks may be delivered multiple times.

---

## Common Patterns

### Free Trial â†’ Paid Subscription

```
1. User signs up â†’ subscription.created (status: "trialing")
2. Trial expires â†’ subscription.trial_expired
3. User pays â†’ subscription.activated (status: "active")
4. Monthly renewal â†’ subscription.renewed + payment.due
```

### Failed Payment Recovery

```
1. Payment fails â†’ payment.failed
2. After 3 failures â†’ subscription.past_due
3. User updates payment â†’ subscription.activated
```

### Plan Changes

```
1. User upgrades â†’ subscription.plan_changed
2. Immediate charge for proration
3. Next renewal uses new plan
```

---

## Support

For integration help:

- CrediBill API Docs: https://docs.credibill.com
- Webhook Testing: https://webhook.site
- Support: support@credibill.com

**Remember**: CrediBill tracks subscriptions, you handle payments. This separation keeps things simple and secure! ðŸš€
